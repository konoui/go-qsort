
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go-qsort: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konoui/go-qsort/heapsort.go (0.0%)</option>
				
				<option value="file1">github.com/konoui/go-qsort/qsort.go (96.9%)</option>
				
				<option value="file2">github.com/konoui/go-qsort/utils.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package qsort

func HeapSort[T any](list []T, cmp func(T, T) int) <span class="cov0" title="0">{
        heapSort(list, 0, len(list), cmp)
}</span>

// https://github.com/apple-oss-distributions/Libc/blob/Libc-1534.81.1/stdlib/FreeBSD/heapsort.c
func heapSort[T any](list []T, off, num int, cmp func(T, T) int) <span class="cov0" title="0">{
        if num &lt;= 1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">base := off - 1
        for l := (num / 2) + 1; l &gt; 0; l-- </span><span class="cov0" title="0">{
                i := l
                j := i * 2
                for ; double(i, &amp;j) &lt;= num; i = j </span><span class="cov0" title="0">{
                        p := base + j
                        //fmt.Printf("loop1: %d %d %d\n", l, i, j)
                        if j &lt; num &amp;&amp; cmp(list[p], list[p+1]) &lt; 0 </span><span class="cov0" title="0">{
                                //fmt.Printf("loop1-swap: %d %d %d\n", l, i, j)
                                p++
                                j++
                        }</span>
                        <span class="cov0" title="0">t := base + i
                        if cmp(list[p], list[t]) &lt;= 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">swap(list, t, p)</span>
                }
        }

        <span class="cov0" title="0">var k T
        for num &gt; 1 </span><span class="cov0" title="0">{
                k = list[base+num] // _copy
                _copy(list, base+num, base+1)
                num--

                i := 1
                j := i * 2
                for ; double(i, &amp;j) &lt;= num; i = j </span><span class="cov0" title="0">{
                        p := base + j
                        //fmt.Printf("loop2: %d %d %d\n", num, i, j)
                        if j &lt; num &amp;&amp; cmp(list[p], list[p+1]) &lt; 0 </span><span class="cov0" title="0">{
                                //fmt.Printf("loop2-swap: %d %d %d\n", num, i, j)
                                p++
                                j++
                        }</span>
                        <span class="cov0" title="0">t := base + i
                        _copy(list, t, p)</span>
                }

                <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                        j := i
                        i = j / 2
                        p := base + j
                        t := base + i
                        //fmt.Printf("loop3: %d %d %d\n", num, i, j)
                        if j == 1 || cmp(k, list[t]) &lt; 0 </span><span class="cov0" title="0">{
                                //fmt.Printf("loop3-swap: %d %d %d\n", num, i, j)
                                list[p] = k // _copy
                                break</span>
                        }
                        <span class="cov0" title="0">_copy(list, p, t)</span>
                }
        }
}

func _copy[T any](list []T, i, j int) <span class="cov0" title="0">{
        list[i] = list[j]
}</span>

func double(i int, j *int) int <span class="cov0" title="0">{
        *j = i * 2
        return *j
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package qsort

// https://github.com/apple-oss-distributions/Libc/blob/Libc-1534.40.2/stdlib/FreeBSD/qsort.c
func Slice[T any](x []T, cmpFunc func(i, j T) int) <span class="cov8" title="1">{
        qsort(x, 0, len(x), cmpFunc, depth(len(x)))
}</span>

func qsort[T any](list []T, off int, num int, cmp func(T, T) int, depthLimit int) <span class="cov8" title="1">{
        utilPrintf("myqsort is called %d\n", depthLimit)
</span>loop:
        <span class="cov8" title="1">swapCnt := 0
        utilPrintf("num %d\n", num)
        if depthLimit &lt;= 0 </span><span class="cov0" title="0">{
                utilPrintf("switch to myheapsort\n")
                heapSort(list, off, num, cmp)
                return
        }</span>
        <span class="cov8" title="1">depthLimit--

        if num &lt;= 7 </span><span class="cov8" title="1">{
                utilPrintf("switch to isort\n")
                iSort(list, off, num, cmp, 0)
                dump(list, off, num)
                return
        }</span>

        <span class="cov8" title="1">pl := off
        pm := off + num/2
        pn := off + num - 1

        if num &gt; 40 </span><span class="cov8" title="1">{
                d := (num / 8)
                pl = med3(list, pl, pl+d, pl+2*d, cmp)
                pm = med3(list, pm-d, pm, pm+d, cmp)
                pn = med3(list, pn-2*d, pn-d, pn, cmp)
                utilPrintf("over 40\n")
        }</span>
        <span class="cov8" title="1">utilPrintf("pl %s\n", cpu(list[pl]))
        utilPrintf("pm %s\n", cpu(list[pm]))
        utilPrintf("pn %s\n", cpu(list[pn]))

        pm = med3(list, pl, pm, pn, cmp)
        utilPrintf("med3 pm %s\n", cpu(list[pm]))

        swap(list, off, pm)
        pa := off + 1
        pb := pa
        pc := off + num - 1
        pd := pc
        for </span><span class="cov8" title="1">{
                for pb &lt;= pc </span><span class="cov8" title="1">{
                        ret := cmp(list[pb], list[off])
                        if ret &lt;= 0 </span><span class="cov8" title="1">{
                                if ret == 0 </span><span class="cov8" title="1">{
                                        utilPrintf("pb &lt;= pc cmp_result=0\n")
                                        swapCnt = 1
                                        swap(list, pa, pb)
                                        pa++
                                }</span>
                                <span class="cov8" title="1">utilPrintf("pb &lt;= pc bp++\n")
                                pb++</span>
                        } else<span class="cov8" title="1"> {
                                break</span>
                        }
                }
                <span class="cov8" title="1">for pb &lt;= pc </span><span class="cov8" title="1">{
                        ret := cmp(list[pc], list[off])
                        if ret &gt;= 0 </span><span class="cov8" title="1">{
                                if ret == 0 </span><span class="cov8" title="1">{
                                        utilPrintf("pb &lt;= pc cmp_result=0\n")
                                        swapCnt = 1
                                        swap(list, pc, pd)
                                        pd--
                                }</span>
                                <span class="cov8" title="1">utilPrintf("pb &lt;= pc pc--\n")
                                pc--</span>
                        } else<span class="cov8" title="1"> {
                                break</span>
                        }
                }

                <span class="cov8" title="1">if pb &gt; pc </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">swap(list, pb, pc)
                swapCnt = 1
                pb++
                pc--</span>
        }

        <span class="cov8" title="1">pn = off + num
        d1 := min(pa-off, pb-pa)
        vecswap(list, off, pb-d1, d1)
        d1 = min(pd-pc, pn-pd-1)
        vecswap(list, pb, pn-d1, d1)

        if swapCnt == 0 </span><span class="cov8" title="1">{
                r := 1 + num/4
                if !iSort(list, off, num, cmp, r) </span><span class="cov8" title="1">{
                        utilPrintf("goto nevermind;\n")
                        goto nevermind</span>
                }
                <span class="cov8" title="1">utilPrintf("return swap_cnt=0 isort\n")
                return</span>
        }

nevermind:
        <span class="cov8" title="1">d1 = pb - pa
        d2 := pd - pc
        if d1 &lt;= d2 </span><span class="cov8" title="1">{
                if d1 &gt; 1 </span><span class="cov8" title="1">{
                        utilPrintf("d1 &gt; 1 do qsort\n")
                        qsort(list, off, d1, cmp, depthLimit)
                }</span>
                <span class="cov8" title="1">if d2 &gt; 1 </span><span class="cov8" title="1">{
                        off = pn - d2
                        num = d2
                        utilPrintf("d2 &gt; 1 goto loop\n")
                        goto loop</span>
                }
        } else<span class="cov8" title="1"> {
                if d2 &gt; 1 </span><span class="cov8" title="1">{
                        utilPrintf("d2 &gt; 1 do qsort\n")
                        qsort(list, pn-d2, d2, cmp, depthLimit)
                }</span>
                <span class="cov8" title="1">if d1 &gt; 1 </span><span class="cov8" title="1">{
                        num = d1
                        utilPrintf("d1 &gt; 1 goto loop\n")
                        goto loop</span>
                }
        }
}

func min(a int, b int) int <span class="cov8" title="1">{
        if a &gt;= b </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return a</span>
}

func vecswap[T any](list []T, a int, b int, n int) <span class="cov8" title="1">{
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                swap(list, a, b)
                a++
                b++
        }</span>
}

func swap[T any](x []T, i, j int) <span class="cov8" title="1">{
        x[i], x[j] = x[j], x[i]
}</span>

func depth(n int) int <span class="cov8" title="1">{
        return 2 * (fls(n) - 1)
}</span>

func med3[T any](list []T, a, b, c int, f func(i, j T) int) int <span class="cov8" title="1">{
        if f(list[a], list[b]) &lt; 0 </span><span class="cov8" title="1">{
                if f(list[b], list[c]) &lt; 0 </span><span class="cov8" title="1">{
                        return b
                }</span> else<span class="cov8" title="1"> {
                        if f(list[a], list[c]) &lt; 0 </span><span class="cov8" title="1">{
                                return c
                        }</span>
                        <span class="cov8" title="1">return a</span>
                }
        } else<span class="cov8" title="1"> {
                if f(list[b], list[c]) &gt; 0 </span><span class="cov8" title="1">{
                        return b
                }</span> else<span class="cov8" title="1"> {
                        if f(list[a], list[c]) &lt; 0 </span><span class="cov8" title="1">{
                                return a
                        }</span> else<span class="cov8" title="1"> {
                                return c
                        }</span>
                }
        }
}

func fls(v int) int <span class="cov8" title="1">{
        if v == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">idx := 1
        tmp := v
        for </span><span class="cov8" title="1">{
                tmp &gt;&gt;= 1
                if tmp == 0 </span><span class="cov8" title="1">{
                        return idx
                }</span>
                <span class="cov8" title="1">idx++</span>
        }
}

func iSort[T any](list []T, off int, len int, cmp func(a, b T) int, swapLimit int) bool <span class="cov8" title="1">{
        swapCnt := 0
        for i := off + 1; i &lt; off+len; i++ </span><span class="cov8" title="1">{
                for j := i; j &gt; off &amp;&amp; cmp(list[j-1], list[j]) &gt; 0; j-- </span><span class="cov8" title="1">{
                        swap(list, j, j-1)
                        swapCnt++
                        if swapLimit &gt; 0 &amp;&amp; swapCnt &gt; swapLimit </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package qsort

import (
        "fmt"
        "io"
        "os"

        "github.com/konoui/lipo/pkg/lipo/lmacho"
)

var (
        Out io.Writer = os.Stdout
)

func utilPrintf(format string, a ...any) <span class="cov8" title="1">{
        fmt.Fprintf(Out, format, a...)
}</span>

func dump[T any](list []T, off int, num int) <span class="cov8" title="1">{
        fmt.Fprintf(Out, "dump-----\n")
        for i := off; i &lt; len(list); i++ </span><span class="cov8" title="1">{
                v := any(list[i]).(lmacho.FatArchHeader)
                fmt.Fprintf(Out, "%v\n", lmacho.ToCpuString(v.Cpu, v.SubCpu))
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(Out, "dump-----\n")</span>
}

func cast[T any](v T) lmacho.FatArchHeader <span class="cov8" title="1">{
        return any(v).(lmacho.FatArchHeader)
}</span>

func cpu[T any](v T) string <span class="cov8" title="1">{
        f := cast(v)
        return lmacho.ToCpuString(f.Cpu, f.SubCpu)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
